/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "obtain_misc.h"

#define SUCCESS    0
#define FAILED    1

extern peers_t          peers;
extern pending_req_t    pending;

int seqno;
pthread_mutex_t seqno_lock = PTHREAD_MUTEX_INITIALIZER;

int
add_req(query_node_t *p)
{
    if (!p) {
        return (FAILED);
    }

    pthread_mutex_lock(pending.lock);
    p->next = pending.head;
    pending.head = p; 
    pending.count++;
    pthread_mutex_unlock(pending.lock);
}

query_node_t * 
remove_node(msg_id_t m)
{
    query_node_t *p, *prev = NULL;
    pthread_mutex_lock(pending.lock);
    p = pending.head;

    if (!p) {
        pthread_mutex_unlock(pending.lock);
        return (NULL);
    }

    /*
     * Handle the head as a special case.
     */
    if (p->id.hostid == m.hostid && p->id.seqno == m.seqno) {
        pending.head = pending.head->next;
        pending.count--;
        pthread_mutex_unlock(pending.lock);
        return (p);
    }

    prev = pending.head;
    p = p->next;

    while (p && (p->id.hostid != m.hostid || p->id.seqno != m.seqno)) {
        prev = p;
        p = p->next;
    }

    if (p) {
        /* 
         * We found a matching node.
         */
        prev->next = p->next;
        pending.count--;
    }
    pthread_mutex_unlock(pending.lock);
    return (p);
}

query_node_t *
find_node(msg_id_t m) 
{
    query_node_t *p = NULL;

    pthread_mutex_lock(pending.lock);
    p = pending.head;

    while (p && (p->id.hostid != m.hostid || p->id.seqno != m.seqno)) {
        p = p->next;
    }

    return (p);
}

bool_t
obtain_1_svc(request *argp, readfile_res *result, struct svc_req *rqstp)
{
    FILE *file;
    int bytes;
    char filepath[MAXPATHLEN];

#ifdef DEBUG
    printf("obtain_1_svc() : Entered : filepath : %s/%s\n", sharedir, argp->name);
#endif

    sprintf(filepath, "%s/%s", sharedir, argp->name);
    file = fopen(filepath, "rb");
    if (file == NULL) {
        printf("Failed to open(%s) : errno %d\n", filepath, errno);
        result->errno = errno;
        return (FALSE);
    }

    fseek (file, argp->seek_bytes, SEEK_SET);
    bytes = fread(result->readfile_res_u.chunk.data, 1, SIZE, file);
    result->readfile_res_u.chunk.bytes = bytes;
    result->errno = 0;
    fclose(file);

    printf("obtain_1_svc() : Served %d bytes from %s at offset : %d\n", bytes, filepath, argp->seek_bytes);
    return (TRUE);

}

int
build_peers_from_cache(char *fname, peers_t *resp)
{
    FILE *fh;
    int cnt = 0;
    char filepath[MAXPATHLEN];
    char *p;
    int fd;
    char host[MAXHOSTNAME+2];

    printf("search_cache : Processing query for file : %s\n", argp->fname);

    resp->count = 0;
    sprintf(filepath, "%s/%s", SERVER_DIR, fname);
    fh = fopen(filepath, "r");
    if (fh == NULL) {
        return (cnt);
    }

    /*
     * If we have reached here there is possibly a peer which is serving this
     * file.
     */
    fd = fileno(fh);

    /*
     * Obtain a shared lock on the file while we are reading the contents.
     * This would block any modifications to the file while we are searching.
     * However, other searches can continue to access it.
     */
    flock(fd, LOCK_SH);

    while (cnt < argp->count && fscanf(fh, "%s\n", host) != EOF) {
	resp->peer[cnt] = malloc((MAXHOSTNAME + 2) * sizeof(char));
	if (resp->peer[cnt] == NULL) {
		printf("search_cache: Out of memory !! Quitting !\n");
		exit (1);	
	}
	strcpy(resp->peer[cnt], host);
        cnt++;
    }

    /*
     * Pass back the count of peers that are serving this file.
     */
	resp->count = cnt;

    flock(fd, LOCK_UN);
    fclose(fh);

#ifdef DEBUG
    {
        int i;
        printf("Peers serving %s = %d \n", fname, resp->count);
        for (i = 0; i < result->count; i++) {
            printf("hostname : %s\n", resp->peer[i]);
        }
    }
#endif /* DEBUG */

	return (cnt);
}

/*
 * TODO : Use the mutex locking around the seq no.
 */
int getseqno(void)
{
    int ret;
    pthread_mutex_lock(seqno_lock);
	seqno++;
    ret = seqno;
    pthread_mutex_unlock(seqno_lock);
	return(ret);
}

bool_t
search_1_svc(query_req *argp, query_rec *result, struct svc_req *rqstp)
{
	bool_t retval;
	b_query query;
	char queryfile[MAXPATHLEN];
	int i;
	peers_t resp;

	query.msg_id.hostid = gethostid();
	query.msg_id.seqno = getseqno(); 

	/*
	 * We symlink a query file of the name "/tmp/queries/<filename>.<seqno>" to
     * the corresponding file in "/tmp/indsvr/<filename>".
	 */
	sprintf(queryfile, "/tmp/queries/%s.%d", argp->fname, query.msg_id.seqno);
	
	fd = open(queryfile, O_CREAT|O_TRUNC|O_RDWR, 0755);
	if (fd < 0) {
		/*
		 * We seem to have a flaw in our logic.
		 */
		printf("The query file %s already exists !\n", queryfile);
		exit(1);
	}	

	/*
	 * Walk through the list of peers and see if we need to relay the query to them.
	 */
	ret = build_peers_from_cache(argp->fname, &resp);

	/*
	 * Copy the cache results first.
	 */
	if (resp->count != 0) {
		
	}
	for (i = 0; i < peers.count; i++) {
		/*
		 * Check we already have the peername in our cache.
		 */
		found = 0;
		for (j = 0; j < resp.count; j++) {
			if(strcmp(resp.peer[j], peers.peer[i]) == 0) {
				found = 1;
				break;
			}
		}
		if (found == 0) {
			
		}
			
	}
	
	

	
	/*
	 * insert server code here
	 */

	return retval;
}

bool_t
b_query_1_svc(b_query_req *argp, int *result, struct svc_req *rqstp)
{
	bool_t retval;

	/*
	 * insert server code here
	 */

	return retval;
}

bool_t
b_hitquery_1_svc(b_hitquery_reply *argp, int *result, struct svc_req *rqstp)
{
	bool_t retval;
	

	/*
	 * insert server code here
	 */

	return retval;
}

int
obtainprog_1_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);

	/*
	 * Insert additional freeing code here, if needed
	 */

	return 1;
}
