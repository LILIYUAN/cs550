/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "ds.h"
#include <sys/vfs.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <dirent.h>
#include <unistd.h>

bool_t
getattr_1_svc(getattr_req *argp, getattr_res *result, struct svc_req *rqstp)
{
	bool_t retval = TRUE;

	/*
	 * insert server code here
	 */
    result.res = stat(argp->name, result->sbuf);

    if (result.res != 0) {
        result.res = -errno;
    }

	return retval;
}

bool_t
readdir_1_svc(readdir_req *argp, readdir_res *result, struct svc_req *rqstp)
{
	bool_t retval = TRUE;
    int ret;

    DIR *dirp;
    struct dirent dent;
    struct dirent *p = NULL;

	/*
	 * insert server code here
	 */
    dirp = opendir(argp->name);
    if (dirp == NULL) {
        result.res = -errno;
        return retval;
    }

    seekdir(dirp, argp->d_off);
    ret = readdir_r(dirp, &dent, &p);

    if (ret != 0) {
        result->res = -errno;
        close(dirp);
        return result;
    }

    result->dent.st_dev = dent.st_dev;
    result->dent.st_ino = dent.st_ino;
    result->dent.st_mode = dent.st_mode;
    result->dent.st_nlink = dent.st_nlink;
    result->dent.st_uid = dent.st_uid;
    result->dent.st_gid = dent.st_gid;
    result->dent.st_rdev = dent.st_gid;
    result->dent.st_size = dent.st_size;    /* total size, in bytes */
    result->dent.st_blksize = dent.st_blksize; /* blocksize for file system I/O */
    result->dent.st_blocks = dent.st_blocks;  /* number of 512B blocks allocated */
    result->dent.st_atime = dent.st_atime;   /* time of last access */
    result->dent.st_mtime = dent.st_mtime;   /* time of last modification */
    result->dent.st_ctime = dent.st_ctime;   /* time of last status change */

    if (p == NULL)
        result->eof = 1;
    else 
        result->eof = 0;

    close(dirp);
	return retval;
}

bool_t
mkdir_1_svc(mkdir_req *argp, mkdir_res *result, struct svc_req *rqstp)
{
    bool_t retval = TRUE;
    int ret;

    ret = mkdir(argp->name, argp->mode);
    if (ret != 0) 
        result->ret = -errno;
    else 
        result->ret = 0;

    return retval;
}

bool_t
unlink_1_svc(unlink_req *argp, unlink_res *result, struct svc_req *rqstp)
{
	bool_t retval = TRUE;
    int ret;

    ret = unlink(argp->name);
    if (ret != 0) 
        result->ret = -errno;
    else 
        result->ret = 0;

	return retval;
}

bool_t
rmdir_1_svc(rmdir_req *argp, rmdir_res *result, struct svc_req *rqstp)
{
	bool_t retval = TRUE;
    int ret;

    ret = rmdir(argp->name);
    if (ret != 0) 
        result->ret = -errno;
    else 
        result->ret = 0;

	return retval;
}

bool_t
rename_1_svc(rename_req *argp, rename_res *result, struct svc_req *rqstp)
{
	bool_t retval = TRUE;
    int ret;

    ret = rename(argp->old, argp->new);
    if (ret != 0) 
        result->ret = -errno;
    else 
        result->ret = 0;

	return retval;
}

bool_t
mknod_1_svc(mknod_req *argp, mknod_res *result, struct svc_req *rqstp)
{
	bool_t retval = TRUE;
    int ret;

    ret = mknod(argp->name, argp->mode, argp->dev);
    if (ret != 0) 
        result->ret = -errno;
    else 
        result->ret = 0;

	return retval;
}

bool_t
create_1_svc(create_req *argp, create_res *result, struct svc_req *rqstp)
{
	bool_t retval = TRUE;
    int ret;

    ret = creat(argp->name, argp->flags, argp->mode);
    if (ret != 0) 
        result->ret = -errno;
    else 
        result->ret = 0;

	return retval;
}

bool_t
open_1_svc(open_req *argp, open_res *result, struct svc_req *rqstp)
{
	bool_t retval = TRUE;
    int fd;

    fd = open(argp->name, argp->flags, argp->mode);
    if (fd < 0) 
        result->ret = -errno;
    else 
        result->ret = fd;

    close(fd);

	return retval;
}

bool_t
close_1_svc(close_res *argp, close_res *result, struct svc_req *rqstp)
{
	bool_t retval = TRUE;

	/*
	 * insert server code here
	 */

	return retval;
}

bool_t
read_1_svc(read_req *argp, read_res *result, struct svc_req *rqstp)
{
	bool_t retval = TRUE;
    int ret;
    int fd;

    fd = open(argp->name, O_RDONLY);
    if (fd  < 0) {
        printf("Failed to open(%s) : errno %d\n", filepath, errno);
        result->res = -errno;
        return (TRUE);
    }

    ret = pread(fd, result->data, argp->count, argp->off);
    close(fd);

    if (ret < 0)
        result->res = -errno;
    else 
        result->res = ret;

	return retval;
}

bool_t
write_1_svc(write_req *argp, write_res *result, struct svc_req *rqstp)
{
	bool_t retval TRUE;
    int ret;
    int fd;

    fd = open(argp->name, O_RDWR);
    if (fd  < 0) {
        printf("Failed to open(%s) : errno %d\n", filepath, errno);
        result->res = -errno;
        return (TRUE);
    }

    ret = pwrite(fd, result->data, argp->count, argp->off);
    close(fd);

    if (ret < 0)
        result->res = -errno;
    else 
        result->res = ret;

	return retval;
}

bool_t
lookup_1_svc(lookup_req *argp, lookup_res *result, struct svc_req *rqstp)
{
	bool_t retval = TRUE;

	/*
	 * insert server code here
	 */

	return retval;
}

bool_t
truncate_1_svc(truncate_req *argp, truncate_res *result, struct svc_req *rqstp)
{
	bool_t retval = TRUE;
    int res;

    res = truncate(argp->name, argp->len);
    if (res < 0) 
        result->res = -errno;
    else
        result->res = 0;
    
	return retval;
}

bool_t
statfs_1_svc(statfs_req *argp, statfs_res *result, struct svc_req *rqstp)
{
	bool_t retval;
    struct statfs sbuf;
    int ret;

    ret = statfs(argp->name, &sbuf);

    if (ret < 0)
        result->res = -errno;
    else
        result->res = 0;

    result->stat.f_type = sbuf.f_type;     /* type of file system (see below) */
    result->stat.f_bsize = sbuf.f_bsize;    /* optimal transfer block size */
    result->stat.f_blocks = sbuf.f_blocks;   /* total data blocks in file system */
    result->stat.f_bfree = sbuf.f_bfree;    /* free blocks in fs */
    result->stat.f_bavail = sbuf.f_bavail;   /* free blocks avail to unprivileged user */
    result->stat.f_files = sbuf.f_files;    /* total file nodes in file system */
    result->stat.f_ffree = sbuf.f_ffree;    /* free file nodes in fs */
    result->stat.f_fsid = sbuf.f_fsid;     /* file system id */
    result->stat.f_namelen = sbuf.f_namelen;  /* maximum length of filenames */
    
	return retval;
}

bool_t
chmod_1_svc(chmod_req *argp, chmod_res *result, struct svc_req *rqstp)
{
	bool_t retval = TRUE;
    int ret;

    ret = chmod(argp->name, argp->mode);
    if (ret < 0)
        result->res = -errno;
    else
        result->res = 0;

	return retval;
}

bool_t
chown_1_svc(chown_req *argp, chown_res *result, struct svc_req *rqstp)
{
	bool_t retval = TRUE;
    int ret;

    ret = chown(argp->name, argp->uid, argp->gid);
    if (ret < 0)
        result->res = -errno;
    else
        result->res = 0;


	return retval;
}

bool_t
link_1_svc(link_req *argp, link_res *result, struct svc_req *rqstp)
{
	bool_t retval = TRUE;
    int ret;

    ret = link(argp->old, argp->new);
    if (ret < 0)
        result->res = -errno;
    else
        result->res = 0;

	return retval;
}

bool_t
symlink_1_svc(symlink_req *argp, symlink_res *result, struct svc_req *rqstp)
{
	bool_t retval = TRUE;
    int ret;

    ret = symlink(argp->old, argp->new);
    if (ret < 0)
        result->res = -errno;
    else
        result->res = 0;

	return retval;
}

bool_t
readlink_1_svc(readlink_req *argp, readlink_res *result, struct svc_req *rqstp)
{
	bool_t retval = TRUE;
    int ret;

    ret = readlink(argp->name, result->buf, argp->bufsize);
    if (ret < 0)
        result->res = -errno;
    else
        result->res = 0;

	return retval;
}

int
dsprog_1_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);

	/*
	 * Insert additional freeing code here, if needed
	 */

	return 1;
}
