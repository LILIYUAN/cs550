/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "obtain.h"

extern peers_t peers;
int seqno;
pthread_mutex_t seqno_mutex;

bool_t
obtain_1_svc(request *argp, readfile_res *result, struct svc_req *rqstp)
{
    FILE *file;
    int bytes;
    char filepath[MAXPATHLEN];

#ifdef DEBUG
    printf("obtain_1_svc() : Entered : filepath : %s/%s\n", sharedir, argp->name);
#endif

    sprintf(filepath, "%s/%s", sharedir, argp->name);
    file = fopen(filepath, "rb");
    if (file == NULL) {
        printf("Failed to open(%s) : errno %d\n", filepath, errno);
        result->errno = errno;
        return (FALSE);
    }

    fseek (file, argp->seek_bytes, SEEK_SET);
    bytes = fread(result->readfile_res_u.chunk.data, 1, SIZE, file);
    result->readfile_res_u.chunk.bytes = bytes;
    result->errno = 0;
    fclose(file);

    printf("obtain_1_svc() : Served %d bytes from %s at offset : %d\n", bytes, filepath, argp->seek_bytes);
    return (TRUE);

}

int
search_cache(char *fname, peers_t *resp)
{
    FILE *fh;
    int cnt = 0;
    char filepath[MAXPATHLEN];
    char *p;
    int fd;
    char host[MAXHOSTNAME+2];

    printf("search_cache : Processing query for file : %s\n", argp->fname);

    resp->count = 0;
    sprintf(filepath, "%s/%s", SERVER_DIR, fname);
    fh = fopen(filepath, "r");
    if (fh == NULL) {
        return (cnt);
    }

    /*
     * If we have reached here there is possibly a peer which is serving this
     * file.
     */
    fd = fileno(fh);

    /*
     * Obtain a shared lock on the file while we are reading the contents.
     * This would block any modifications to the file while we are searching.
     * However, other searches can continue to access it.
     */
    flock(fd, LOCK_SH);

    while (cnt < argp->count && fscanf(fh, "%s\n", host) != EOF) {
	resp->peer[cnt] = malloc((MAXHOSTNAME + 2) * sizeof(char));
	if (resp->peer[cnt] == NULL) {
		printf("search_cache: Out of memory !! Quitting !\n");
		exit (1);	
	}
	strcpy(resp->peer[cnt], host);
        cnt++;
    }

    /*
     * Pass back the count of peers that are serving this file.
     */
	resp->count = cnt;

    flock(fd, LOCK_UN);
    fclose(fh);

#ifdef DEBUG
    {
        int i;
        printf("Peers serving %s = %d \n", fname, resp->count);
        for (i = 0; i < result->count; i++) {
            printf("hostname : %s\n", resp->peer[i]);
        }
    }
#endif /* DEBUG */

	return (cnt);
}

/*
 * TODO : Use the mutex locking around the seq no.
 */
int getseqno(void)
{
	seqno++;
	return(seqno);
}

bool_t
search_1_svc(query_req *argp, query_rec *result, struct svc_req *rqstp)
{
	bool_t retval;
	b_query query;
	char queryfile[MAXPATHLEN];
	int i;
	peers_t resp;

	query.msg_id.hostid = gethostid();
	query.msg_id.seqno = getseqno(); 

	/*
	 * We create a query file of the name "/tmp/queries/<filename>.<seqno>".
	 */
	sprintf(queryfile, "/tmp/queries/%s.%d", argp->fname, query.msg_id.seqno);
	
	fd = open(queryfile, O_CREAT|O_TRUNC|O_RDWR, 0755);
	if (fd < 0) {
		/*
		 * We seem to have a flaw in our logic.
		 */
		printf("The query file %s already exists !\n", queryfile);
		exit(1);
	}	

	/*
	 * Walk through the list of peers and see if we need to relay the query to them.
	 */
	ret = search_cache_(argp->fname, &resp);

	/*
	 * Copy the cache results first.
	 */
	if (resp->count != 0) {
		
	}
	for (i = 0; i < peers.count; i++) {
		/*
		 * Check we already have the peername in our cache.
		 */
		found = 0;
		for (j = 0; j < resp.count; j++) {
			if(strcmp(resp.peer[j], peers.peer[i]) == 0) {
				found = 1;
				break;
			}
		}
		if (found == 0) {
			
		}
			
	}
	
	

	
	/*
	 * insert server code here
	 */

	return retval;
}

bool_t
b_query_1_svc(b_query_req *argp, int *result, struct svc_req *rqstp)
{
	bool_t retval;

	/*
	 * insert server code here
	 */

	return retval;
}

bool_t
b_hitquery_1_svc(b_hitquery_reply *argp, int *result, struct svc_req *rqstp)
{
	bool_t retval;
	

	/*
	 * insert server code here
	 */

	return retval;
}

int
obtainprog_1_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);

	/*
	 * Insert additional freeing code here, if needed
	 */

	return 1;
}
